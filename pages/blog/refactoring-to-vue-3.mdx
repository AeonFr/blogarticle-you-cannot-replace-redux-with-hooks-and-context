import BlogCodeWalkthroughLayout from "../../components/BlogCodeWalkthroughLayout";
export default (props) => <BlogCodeWalkthroughLayout {...props} />;

# Composition API

## Reusable **stateful logic** in VueJS

---

## UI as a function of state

One of the core principles of React, Vue and other frameworks or libraries, is that the UI is a result of passing **state** through a function.

<small>

(you don't even need a framework to apply this concept)

</small>

But what is **state** exactly?

```js
UI = fn(state);
```

---

<div style={{ fontSize: "1.5em" }}>

**State** is data that changes over time. In other words, a **data stream**.

</div>

<img src="/blog/refactoring-to-vue-3/state-stream.svg" alt="Visual representation of a data stream (described below)" style={{backgroundColor: "#ffffff"}}/>

For example, if we have a Button that retrieves data from the server and updates a list of items, the **state** would be the retrieved data.

Additionally, we can call **stateful logic** to the click interaction, the data fetching process, etc.

<div style={{ fontSize: "1.5em" }}>

**Stateful logic** is all the logic involved in mutating state.

</div>

---

## Stateful logic in Vue

Let's see how we could represent some simple stateful logic in a VueJS component.

---

We will start with a component that shows the current window width.

```html
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
  };
</script>
```

---

The value of the window width is calculated when the component is mounted, but it's not updated afterwards if the user resizes the browser.

Let's fix that!

```html 9
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
  };
</script>
```

---

To fix this, we can add **resize** event handlers to our component.

```html 11:28
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
    mounted() {
      window.addEventListener(
        "resize",
        this.calculateWindowWidth
      );
    },
    beforeDestroy() {
      window.removeEventListener(
        "resize",
        this.calculateWindowWidth
      );
    },
    methods: {
      calculateWindowWidth() {
        this.windowWidth = window.innerWidth;
      },
    },
  };
</script>
```

---

It's a good practice to **throttle** the resize event, otherwise this component will update many times per second while the user is scrolling, and that might cause the experience to feel "laggy".

We can add a throttled version of the `calculateWindowWidth`, and use it as the event listener function.

```html 17, 23, 30:32
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  import throttle from "lodash/throttle";

  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
    mounted() {
      window.addEventListener(
        "resize",
        this.calculateWindowWidthThrottled
      );
    },
    beforeDestroy() {
      window.removeEventListener(
        "resize",
        this.calculateWindowWidthThrottled
      );
    },
    methods: {
      calculateWindowWidth() {
        this.windowWidth = window.innerWidth;
      },
      calculateWindowWidthThrottled: throttle(function () {
        this.calculateWindowWidth();
      }, 200),
    },
  };
</script>
```

---

By now our component has quite some **stateful logic**, even though it fulfills a very simple purpose.

```html
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  import throttle from "lodash/throttle";

  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
    mounted() {
      window.addEventListener(
        "resize",
        this.calculateWindowWidthThrottled
      );
    },
    beforeDestroy() {
      window.removeEventListener(
        "resize",
        this.calculateWindowWidthThrottled
      );
    },
    methods: {
      calculateWindowWidth() {
        this.windowWidth = window.innerWidth;
      },
      calculateWindowWidthThrottled: throttle(function () {
        this.calculateWindowWidth();
      }, 200),
    },
  };
</script>
```

To make this logic easily reusable, and to clean up our code, we can create a **composition function**.

<div style={{ fontSize: "1.5em" }}>

A **composition function** (known as a **hook** in React) is a way to encapsulate stateful logic so that it's reusable between components, or in other composition functions.

</div>

---

Sounds confusing? Let's go step by step...
