import BlogCodeWalkthroughLayout from "../../components/BlogCodeWalkthroughLayout";
export default (props) => <BlogCodeWalkthroughLayout {...props} />;

# Composition API

## Reusable **stateful logic** in VueJS

---

## UI as a function of state

One of the core principles of React, Vue and other frameworks or libraries, is that the UI is a result of passing **state** through a function.

<small>

(you don't even need a framework to apply this concept)

</small>

So, what is **state**?

```js
UI = fn(state);
```

---

**State** is data that changes over time. In other words, a **data stream**.

**Stateful logic** is all the logic that causes state updates. These are the rules that the state follows.

---

## Example

Let's think of a UI with a Button that retrieves data from the server and updates a list of items. This could be something like an email client or a newsfeed.

### UI = fn(state)

Every time the state changes, a function is called with the new state. The result of the function is the updated UI.

### Stateful logic

The stateful logic here would be the relation between the click event, the communication with the server, and the change in state.

<img src="/blog/refactoring-to-vue-3/state-stream.svg" alt="" style={{backgroundColor: "#ffffff99"}}/>

---

## Stateful logic in Vue

Let's see how we could represent some simple stateful logic in a VueJS component.

We will start with a component that renders the current window width.

```html
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
  };
</script>
```

---

The value of the window width is calculated when the component is mounted, but it's not updated afterwards if the user resizes the browser.

Let's fix that!

```html 9
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
  };
</script>
```

---

To fix this, we can add **resize** event handlers to our component.

```html 11:28
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
    mounted() {
      window.addEventListener(
        "resize",
        this.calculateWindowWidth
      );
    },
    beforeDestroy() {
      window.removeEventListener(
        "resize",
        this.calculateWindowWidth
      );
    },
    methods: {
      calculateWindowWidth() {
        this.windowWidth = window.innerWidth;
      },
    },
  };
</script>
```

---

It's a good practice to **throttle** the resize event, otherwise this component will update many times per second while the user is scrolling, and that might cause the experience to feel "laggy".

We can add a throttled version of the `calculateWindowWidth`, and use it as the event listener function.

```html 17, 23, 30:32
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  import throttle from "lodash/throttle";

  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
    mounted() {
      window.addEventListener(
        "resize",
        this.calculateWindowWidthThrottled
      );
    },
    beforeDestroy() {
      window.removeEventListener(
        "resize",
        this.calculateWindowWidthThrottled
      );
    },
    methods: {
      calculateWindowWidth() {
        this.windowWidth = window.innerWidth;
      },
      calculateWindowWidthThrottled: throttle(function () {
        this.calculateWindowWidth();
      }, 200),
    },
  };
</script>
```

---

By now our component has quite some **stateful logic**, even though it fulfills a very simple purpose.

Unfortunately, without using the composition API, we **can't reuse** this logic in other components\*.

<small style={{ opacity: 0.6 }}>

\* Unless we use Mixins, <a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" referer="noindex nofollow">but they break some SOLID principles and go against good practices</a>.

</small>

Let's refactor this stateful logic into a **composition function** to make it reusable.

```html
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  import throttle from "lodash/throttle";

  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
    mounted() {
      window.addEventListener(
        "resize",
        this.calculateWindowWidthThrottled
      );
    },
    beforeDestroy() {
      window.removeEventListener(
        "resize",
        this.calculateWindowWidthThrottled
      );
    },
    methods: {
      calculateWindowWidth() {
        this.windowWidth = window.innerWidth;
      },
      calculateWindowWidthThrottled: throttle(function () {
        this.calculateWindowWidth();
      }, 200),
    },
  };
</script>
```
