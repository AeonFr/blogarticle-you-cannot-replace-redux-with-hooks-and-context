export const metadata = {
  title: "Generating color palettes with code",
  date: "2021-07-02",
  description:
    "Why you should never generate color palettes using sass' functions like darken() or do math with hsl()",
  isDraft: true,
};

import BlogPostLayout from "../../components/BlogPostLayout";
export default ({ children }) => (
  <BlogPostLayout {...metadata}>{children}</BlogPostLayout>
);

import { ColorPalette } from "../../components/blog/generated-color-palettes/ColorPalette";
import {
  SaturationSlider,
  HueSlider,
} from "../../components/blog/generated-color-palettes/ColorSliders";
import {
  Column,
  Row,
  Spacer,
} from "../../components/blog/generated-color-palettes/ColumnSection";
import {
  Headline,
  SmallText,
  BigText,
} from "../../components/blog/generated-color-palettes/Text";
import {
  LegibilityBrokenSample,
  ContrastBrokenSample,
  HueBrokenSample,
  ButtonIsBrokenSample,
} from "../../components/blog/generated-color-palettes/Samples";

<Headline>{metadata.title}</Headline>

Most screens and monitors use the sRGB color spectrum, which basically means they can represent a limited subset of the colors we can see in real life.

<Column tag="figure" style={{  fontSize: "0.8em", margin: "0" }}>

<Row
  tag="img"
  src="/blog/generated-color-palettes/CIExy1931_sRGB.svg"
  alt="Visual representation of the sRGB color spectrum inside the 'shoe-shaped' visual spectrum"
  style={{ backgroundColor: "white", width: "20em" }}
/>

<Row tag="figcaption" style={{  width: '20em', textAlign: 'left' }}>

**sRGB color spectrum** (black triangle), as compared to the color range visible by the human eye ("shoe shape").

[Via Wikimedia Commons](https://commons.wikimedia.org/wiki/File:CIExy1931_sRGB.svg), [CC BY-SA 3.0](http://creativecommons.org/licenses/by-sa/3.0)

</Row>

</Column>

When you see an **hexadecimal color** (like `#FF0000`) or a **CSS color value** (like `rgb(100,0,0)`), you are seeing the **representation of a color inside the sRGB spectrum**, the color scheme used by the browser. These are instructions that the browser sends to your screen to render a color inside the specified color range.

<SmallText>

As a side-note, not all monitors use sRGB; Apple monitors use Apple RGB or Display-P3, spectrums that allow access to a wider color gamut than sRGB. But this technologies are not standards, and CSS has not adapted to them yet; only the sRGB spectrum is supported right now.

</SmallText>

## So let's say you want a color palette for the web

The `hsl()` function is a CSS function used to express any hexadecimal color. It's called hsl because it receives three arguments: Hue, Saturation and Luminosity.

This CSS function â€“unlike `rgb()` or an hexadecimal stringâ€“ accepts a distinct argument for luminosity, which makes it particularly suited to generate color palettes based on different lights and shadows of the same color.

For example, we can set a fixed value for hue and saturation, and increment lightness by 10%, from 0 to 100 (11 steps in total), to get a white to black gradient.

We can even go a step further and use [for-loops in Sass](https://sass-lang.com/documentation/at-rules/control/for) to make the code less repetitive.

<SmallText>

```scss
.palette.gray {
  $hue: 0;
  $saturation: 0%;
  @for $i from 0 through 10 {
    .step:nth-child(#{$i + 1}) {
      background-color: hsl($hue, $saturation, $i * 10%);
    }
  }
}
```

</SmallText>

The result looks like this:

<p
  className="codepen"
  data-height="170"
  data-slug-hash="BaRRrRZ"
  data-editable="true"
  data-user="frankno"
  style={{
    height: "170px",
    boxSizing: "border-box",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    border: "2px solid",
    margin: "1em 0",
    padding: "1em",
  }}
>
  <span>
    See the Pen{" "}
    <a href="https://codepen.io/frankno/pen/BaRRrRZ">SASS playground</a> by
    francisco (<a href="https://codepen.io/frankno">@frankno</a>) on{" "}
    <a href="https://codepen.io">CodePen</a>.
  </span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

We can also use JSX to express this color palette, with a component like this:

<SmallText>

<!-- prettier-ignore -->
```jsx
export const ColorPalette = () => {
  return (
    <div style={{ display: "grid", gridTemplateColumns: "repeat(11, 1fr)" }}>
      {[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100].map((step) => (
        <div
          key={step}
          style={{
            backgroundColor: `hsl(0, 0%, ${step}%)`,
            aspectRatio: "1 / 1",
          }}
        />
      ))}
    </div>
  );
};
```

</SmallText>

<ColorPalette />

So far so good, right?

## Hue and saturation

Let's try to apply this to generate palettes in different colors (besides gray)

<Column>
  <Row style={{ maxWidth: "14rem" }}>
    <SaturationSlider />
  </Row>
  <Row style={{ minWidth: "20rem" }}>

If we increase the color's **saturation**, (the **s** in **hsl()**) we can see how color starts to appear. In this case, since our hue is 0, we will see the color <strong style={{ color: "red" }}>red</strong>.

<SmallText>

Try it yourself: move the saturation slider until you see the box fill up in red.

</SmallText>

  </Row>
</Column>

<Spacer />

<Column>
  <Row style={{ maxWidth: "14rem" }}>
    <HueSlider />
  </Row>
  <Row style={{ minWidth: "20rem" }}>

We can also increase the **hue** (the **h** in **hsl()**), using values from 0 to 360, to get colors from all the sRGB spectrum.

  </Row>
</Column>

Given all we've discovered so far, we could try to create palettes using the arguments of the `hsl()` function.

Let's generate a palette for each hue, by using our `ColorPalette` component multiple times in the following way:

<SmallText>

```jsx
<ColorPalette hue={0} />
<ColorPalette hue={60} />
<ColorPalette hue={180} />
<ColorPalette hue={200} />
```

Behind the scenes, I did a small refactor to the ColorSlider component to make it accept hue as a prop. You can see [the component's source code in github](https://github.com/AeonFr/dev.franciscobrusa.www-next/blob/main/components/blog/generated-color-palettes/ColorPalette.jsx), since this website is open-source. ðŸ˜‰

</SmallText>

The result we would get surely must be a harmonic color palette, right?

<ColorPalette hue={0} saturation={100} />
<ColorPalette hue={60} saturation={100} />
<ColorPalette hue={180} saturation={100} />
<ColorPalette hue={200} saturation={100} />

Well, as we can see, not so much. We have inconsistencies all around!

<Column>
  <Row style={{ minWidth: "20rem" }}>

For example, even at the same luminosity of 50%, blue text is perfectly readable at a white background, while yellow text is perfectly readable at a black background. Inverting backgrounds, though, might make readability really difficult.

_Do these colors really have the same luminosity?_

</Row>
<Row style={{ maxWidth: "14rem" }}>
  <LegibilityBrokenSample/>
</Row>
</Column>

<Spacer />

<Column>
<Row style={{ minWidth: "20rem" }}>

Other colors have steps that are almost impossible to distinguish.

For example, in the image we have two colors at 50% and 60% luminosity. While for purple we can clearly perceive two colors, the two steps of yellow are almost impossible to tell apart.

</Row>
<Row style={{ maxWidth: "14rem" }}>
  <ContrastBrokenSample/>
</Row>
</Column>

<Spacer />

<Column>
<Row style={{ minWidth: "20rem" }}>

To make things worse, the value for hue is also misleading. The orange/yellow colors in the image have the same hue difference as the blue colors, yet the blue colors look exactly the same, while the oranges look very distinct.

</Row>
<Row style={{ maxWidth: "14rem" }}>
  <HueBrokenSample/>
</Row>
</Column>

And let's not even look into start changing saturation, because that value tends to be misleading as well!

Therefore, **this method to generate palettes is not reliable**. You do not want to use colors generated this way to generate button variants, or any other piece of UI where legibility and consistency is important. (Basically everything?)

For example, here are some button variants using the same steps of different colors from the palettes from above...

<ButtonIsBrokenSample />

Looks terrible, right?

<BigText>

As we've seen, you can't just "do math" with the params of `hsl()`. The same problems occur with Sass' `lighten()` and `darken()` functions.

But, if we can't use `hsl()`, `lighten()` or `darken()`, **what can we do?**

</BigText>

<Headline tag="h2" style={{ marginTop: "4em", maxWidth: "13em" }}>
  HSLUV:
  <br />
  The human-friendly, intuitive alternative to HSL
</Headline>

What if we could represent
