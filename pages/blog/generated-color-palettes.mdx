export const metadata = {
  title: "Generating color palettes with code",
  date: "2021-07-02",
  socialImage: "/blog/generated-color-palettes/social-image.png",
  description:
    "Why you shouldn‚Äôt trust color functions like hsl(), lighten() or darken()",
};

import BlogPostLayout from "../../components/BlogPostLayout";
export default ({ children }) => (
  <BlogPostLayout {...metadata}>{children}</BlogPostLayout>
);

import {
  ColorPalette,
  HSLuvColorPalette,
} from "../../components/blog/generated-color-palettes/ColorPalette";
import {
  RGBSlider,
  SaturationSlider,
  HueSlider,
  ColorPaletteSlider,
  HSLuvColorPaletteSlider,
} from "../../components/blog/generated-color-palettes/ColorSliders";
import {
  Row,
  Col,
  Spacer,
} from "../../components/blog/generated-color-palettes/RowSection";
import {
  Headline,
  SmallText,
  BigText,
} from "../../components/blog/generated-color-palettes/Text";
import {
  LegibilityBrokenSample,
  ContrastBrokenSample,
  HueBrokenSample,
  ButtonIsBrokenSample,
} from "../../components/blog/generated-color-palettes/Samples";

<Headline>{metadata.title}</Headline>

Most screens and monitors use the sRGB color spectrum, which basically means they can represent a limited subset of the colors we can see in real life.

<Row tag="figure" style={{  fontSize: "0.8em", margin: "0" }}>

<Col
  tag="img"
  src="/blog/generated-color-palettes/CIExy1931_sRGB.svg"
  alt="Visual representation of the sRGB color spectrum inside the 'shoe-shaped' visual spectrum"
  style={{ backgroundColor: "white", width: "20em" }}
/>

<Col tag="figcaption" style={{  width: '20em', textAlign: 'left' }}>

**sRGB color spectrum** (black triangle), as compared to the color range visible by the human eye ("shoe shape").

[Via Wikimedia Commons](https://commons.wikimedia.org/wiki/File:CIExy1931_sRGB.svg), [CC BY-SA 3.0](http://creativecommons.org/licenses/by-sa/3.0)

</Col>

</Row>

When you see an **hexadecimal color** (like `#FF0000`) or a **CSS color value** (like `rgb(100,0,0)`), you are seeing the **representation of a color inside the sRGB spectrum**, the color scheme used by the browser. These are instructions that the browser sends to your screen to render a color inside the specified color range.

<SmallText>

As a side-note, not all monitors use sRGB; Apple monitors use Apple RGB or Display-P3, spectrums that allow access to a wider color gamut than sRGB. But this color spaces are not industry standards (yet?), and CSS is not prepared to use them.

</SmallText>

There are many ways to represent sRGB colors, the most common one is the hexadecimal notation, which works by setting a value for Red, Green and Blue.

<RGBSlider />

Although the resulting hexadecimal value is a short string, this method for choosing colors is not particularly intuitive. We don't often think about colors as the addition of other colors. To make a better mental model, HSL was created.

## Hue, saturation, luminosity

As an alternative to `rgb()`, `hsl()` is a CSS function used to express any hexadecimal color. It's called HSL because it receives three arguments: Hue, Saturation and Luminosity.

This function alows for more intuitive ways to tweak its values.

For example, we can set a fixed value for hue and saturation, and increment lightness by 10%, from 0 to 100 (11 steps in total), to get a palette.

This is the result of going from `hsl(0, 0%, 0%)` to `hsl(0, 0%, 100%)`

<ColorPalette saturation={0} />

But because we don't want to only use grays, let's see how to obtain colors using `hsl()`.

<Row>
  <Col style={{ maxWidth: "14rem" }}>
    <SaturationSlider />
  </Col>
  <Col style={{ minWidth: "20rem" }}>

If we increase **saturation**, (the **s** in **hsl()**) we can see how color starts to appear. In this case, since our hue is 0, we will see the color <strong style={{ color: "red" }}>red</strong>.

<SmallText>

Try it yourself: move the saturation slider until you see the box fill up in red.

</SmallText>

  </Col>
</Row>

<Spacer />

<Row>
  <Col style={{ maxWidth: "14rem" }}>
    <HueSlider />
  </Col>
  <Col style={{ minWidth: "20rem" }}>

We can also change **hue** (the **h** in **hsl()**), using values from 0 to 360, to get colors from all the sRGB spectrum.

  </Col>
</Row>

## Generating color palettes

Given all we've discovered so far, we could try to create palettes using the arguments of the `hsl()` function.

Here we have an implementation of the gray palette using [for-loops in Sass](https://sass-lang.com/documentation/at-rules/control/for).

```scss
.palette.gray {
  $hue: 0;
  $saturation: 0%;
  @for $i from 0 through 10 {
    .step:nth-child(#{$i + 1}) {
      background-color: hsl($hue, $saturation, $i * 10%);
    }
  }
}
```

The result looks like this:

<SmallText>

<ColorPalette hue={0} saturation={0} />

[Check the demo on CodePen.](https://codepen.io/frankno/pen/BaRRrRZ)

</SmallText>

Given a fixed value for hue (0) and saturation (0%), we generated classes that apply different degrees of luminosity. Basically we go from `hsl(0, 0%, 0%)` to `hls(0, 0%, 100%)`, by steps of `10%`.

We can also use JSX to express this color palette, with a component like this:

<SmallText>

<!-- prettier-ignore -->
```jsx
export const ColorPalette = ({ hue = 0, saturation = 100 }) => {
  return (
    <div style={{ display: "grid", gridTemplateRows: "repeat(11, 1fr)" }}>
      {[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100].map((lightness) => (
        <div
          key={lightness}
          style={{
            backgroundColor: `hsl(${hue}, ${saturation}%, ${lightness}%)`,
            aspectRatio: "1 / 1",
          }}
        />
      ))}
    </div>
  );
};
```

</SmallText>

This component can then be used like this:

```jsx
<ColorPalette hue={325} saturation={90} />
```

Try it yourself below! (Move the sliders to see how the component reacts to different values of hue and saturation).

<ColorPaletteSlider />

Let's go ahead and generate a palette for different hues, by using our `ColorPalette` component multiple times in the following way:

<SmallText>

```jsx
<ColorPalette hue={0} />
<ColorPalette hue={60} />
<ColorPalette hue={180} />
<ColorPalette hue={230} />
<ColorPalette hue={270} />
```

</SmallText>

<ColorPalette hue={0} />
<ColorPalette hue={60} />
<ColorPalette hue={180} />
<ColorPalette hue={230} />
<ColorPalette hue={270} />

You might think this is a good method to generate color palettes for graphic design or the web. After all, the result we would get surely must be a harmonic color palette... right?
Well, as we can see, not so much. We have inconsistencies all around!

<Row>
  <Col style={{ minWidth: "20rem" }}>

For example, even at the same luminosity of 50%, blue text is perfectly readable at a white background, while yellow text is only readable with a black background.

_According to the HSL function, these colors have the same luminosity. But do these colors really have the same luminosity?_ üßê

</Col>
<Col style={{ maxWidth: "14rem", alignSelf: "flex-end" }}>
  <LegibilityBrokenSample/>
</Col>
</Row>

<Spacer />

<Row>
<Col style={{ minWidth: "20rem" }}>

Other colors have steps that are almost impossible to distinguish.

For example, in this sample we have two colors at 50% and 60% luminosity. While for purple we can clearly perceive two different "shadows", the two shadows of teal are almost impossible to tell apart.

</Col>
<Col style={{ maxWidth: "14rem", alignSelf: "flex-end" }}>
  <ContrastBrokenSample/>
</Col>
</Row>

<Spacer />

<Row>
<Col style={{ minWidth: "20rem" }}>

To make things worse, the value for hue does not change uniformly either. The colors from the top in the following image have the same hue difference as the blue colors from the bottom. Both differ by 30 degrees. Yet, the hue difference is much more noticeable for the orange and yellow.

</Col>
<Col style={{ maxWidth: "14rem", alignSelf: "flex-end" }}>
  <HueBrokenSample/>
</Col>
</Row>

And let's not even look into start changing saturation, because that value tends to be misleading as well!

Therefore, **this method to generate palettes is not reliable**. You do not want to use colors generated this way to generate button variants, or any other piece of UI where legibility and consistency is important.

<BigText>

As we've seen, you can't just "do math" with the params of `hsl()`. The same problems occur with Sass' `lighten()` and `darken()` functions.

Why is HSL so "broken"?

</BigText>

<Headline tag="h2" style={{ marginTop: "4em", maxWidth: "13em" }}>
  The problem with HSL
</Headline>

Let's look again at the sRGB spectrum inside the "shoe-shaped" figure (this "shoe shape" is actually a representation of the [CIE XYZ color space](https://en.wikipedia.org/wiki/CIE_1931_color_space), a color space that **takes into account psychological perception**).

<Row as="figure">
  <Col
    tag="img"
    src="/blog/generated-color-palettes/CIExy1931_sRGB_with_markers.svg"
    style={{ backgroundColor: "white", width: "20em" }}
  />
  <Col tag="figcaption" style={{  width: '20em', textAlign: 'left' }}>

In this figure, line **`a`** represents the distance of teal at 50% and 75% luminosity.

Line **`b`** represents the distance of blue at 50% and 75% luminosity.

According to the HSL function, the distance variation is the same, 25% for both cases.

But, _are this distances really the same?_ üßê

</Col>
</Row>

Well, as we can see in the graphic, **clearly not**.

If we only consider "the amount of power the LED pixel is using", we could say the screen is using, for both cases, 50% and 75% of it's full capacity.

But if we compare this output with a model that takes into account psychological perception, we can see that the screen is limited when representing certain colors, which causes distortions in the results of HSL.

<BigText>

**HSL was created to be fast, not to be perceptually accurate**. It's a model based on how monitors output color, not on how humans perceive it.

</BigText>

Luckily, smarter people have come up with solutions and alternatives to deal with color in code. We'll explore one of them, HSLuv.

<Headline tag="h2" style={{ marginTop: "4em", maxWidth: "13em" }}>
  HSLuv:
  <br />
  The human-friendly alternative to HSL
</Headline>

[HSLuv](https://www.hsluv.org/) is a color space designed for **perceptual uniformity**.

It's based on the CIELUV color space, created in 1976 based on experiments that tried to "marry" the distributions of color wavelengths with the psychologically perceived colors in human vision.

To say it plainly, HSLuv aims to make it easier to reason about color.

It is commonly used for:

1. Generating colors for statistical graphics and data visualization software.
2. Generating themes, like this neat [code syntax highlighter theme generator](https://www.syntaxenvy.com/0104550).
3. Build color palettes with consistent contrast ratios, like the one created for [Polaris](https://polaris.shopify.com/), Shopify's design system.

HSLuv has dozens of open-source implementations for different programming languages, but we'll focus only on JavaScript.

The JavaScript implementation has a tiny footprint in bundle size (2kb) and a very simple API.

```js
import hsluv from "hsluv";

// Convert hsluv to hex
hsluv.hsluvToHex([hue, saturation, lightness]);

// Convert hex to hsluv
hsluv.hexToHsluv(hex);
```

Once we have a HSLuv value, changing it's lightness for different hues will produce uniform palettes. The result is not guaranteed to be 100% accurate, but it gives decent enough results for some use cases. For other use cases, some optical adjustments in certain colors might be needed.

Let's look at an implementation of the `ColorPalette` component using HSLuv. To achieve this, we only need to make a small change in line 8.

<SmallText>

<!-- prettier-ignore -->
```jsx 8
export const ColorPalette = ({ hue = 0, saturation = 100 }) => {
  return (
    <div style={{ display: "grid", gridTemplateRows: "repeat(11, 1fr)" }}>
      {[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100].map((lightness) => (
        <div
          key={lightness}
          style={{
            backgroundColor: hsluv.hsluvToHex([hue, saturation, lightness]),
            aspectRatio: "1 / 1",
          }}
        />
      ))}
    </div>
  );
};
```

</SmallText>

<HSLuvColorPaletteSlider />

Let's try to generate the same palettes as before, and compare the results.

**The code:**

```jsx
<ColorPalette hue={0} />
<ColorPalette hue={60} />
<ColorPalette hue={180} />
<ColorPalette hue={230} />
<ColorPalette hue={270} />
```

**HSL implementation (for reference):**

<ColorPalette hue={0} />
<ColorPalette hue={60} />
<ColorPalette hue={180} />
<ColorPalette hue={230} />
<ColorPalette hue={270} />

**HSLuv implementation:**

<HSLuvColorPalette hue={0} />
<HSLuvColorPalette hue={60} />
<HSLuvColorPalette hue={180} />
<HSLuvColorPalette hue={230} />
<HSLuvColorPalette hue={270} />

You might notice that colors outputted by this method look more uniform. Although, since HSLuv makes some corrections in the Hue dimension, to get the same hues as before we might need to make some adjustments.

Let's look for example at the red color: it looks like magenta in HSLuv. The Hue for red in HSL might not necessarily have the same value in HSLuv. To get the value in HSLuv, we can execute this JS:

```js
hsluv.hexToHsluv("#ff0000");
// [12.177050630061776, 100.0000000000022, 53.23711559542933]
```

As we can see, HSLuv needs a value of `12` for hue to show red. Let's paint the palette again after this optical adjustments...

**HSL implementation (for reference):**

<ColorPalette hue={0} />
<ColorPalette hue={60} />
<ColorPalette hue={180} />
<ColorPalette hue={230} />
<ColorPalette hue={270} />

**HSLuv implementation:**

<HSLuvColorPalette hue={12} />
<HSLuvColorPalette hue={86} />
<HSLuvColorPalette hue={192} />
<HSLuvColorPalette hue={265} />
<HSLuvColorPalette hue={274} />

As you might see, the HSLuv implementation is much better at keeping consistency and preserving contrast for different colors.

Still, according to personal preference, some optical adjustments might be needed. For example, HSLuv tends to remove too much saturation and makes some colors look dull.

For some scenarios, it might make sense to sacrifice some uniformity in the contrast dimension in pro of having more saturated colors. This tradeoff might make sense for some cases and not for others, so it's impossible for a fully automated tool to make this kind of judgments.

<BigText>

HSLuv makes reasoning about color, and doing "math" with colors, a much more intuitive process.

</BigText>

---

Links of interest:

- [HSLuve Figma plugin](https://www.figma.com/community/plugin/811341846366740536/HSLuve) displays an HSLuv color selector inside Figma.
- [Chromatic Figma plugin](https://www.figma.com/community/plugin/759433498184507623/Chromatic-Figma) fix gradients to achieve perceptual uniformity.
- [postcss-plugi-hsluv](https://www.npmjs.com/package/postcss-plugin-hsluv) brings HSLuv to PostCSS.
- [hsluv-sass](https://www.npmjs.com/package/hsluv-sass) brings HSLuv to Sass
- [hsluv-stylus](https://www.npmjs.com/package/hsluv-stylus) brings HSLuv to Stylus
