export const metadata = {
  title: "Generating color palettes with code",
  date: "2021-07-02",
  description:
    "Why you should never generate color palettes using sass' functions like darken() or do math with hsl()",
  isDraft: true,
};

import BlogPostLayout from "../../components/BlogPostLayout";
export default ({ children }) => (
  <BlogPostLayout {...metadata}>{children}</BlogPostLayout>
);

import { ColorPalette } from "../../components/blog/generated-color-palettes/ColorPalette";
import {
  SaturationSlider,
  HueSlider,
} from "../../components/blog/generated-color-palettes/ColorSliders";

<h1
  style={{
    maxWidth: "35rem",
    fontSize: "2.5em",
    backgroundImage:
      "linear-gradient(90deg, var(--accent, #00DBDE) 0%, var(--function, #FC00FF) 100%)",
    backgroundClip: "text",
    "-webkit-background-clip": "text",
    textFillColor: "transparent",
    "-webkit-text-fill-color": "transparent",
  }}
>
  {metadata.title}
</h1>

The `hsl()` function is a CSS function used to express any hexadecimal color. It's called hsl because it receives three arguments: Hue, Saturation and Luminosity.

With these three values you can generate any color from the [sRGB color space](https://en.wikipedia.org/wiki/SRGB), any hexadecimal color.

Since this CSS function –unlike `rgb()`– accepts a single argument for luminosity, it seems particularly suited to generate color palettes.
For example, we can set a fixed value for hue and saturation, and increment lightness by 10%, from 0 to 100 (11 steps in total), to get a white to black gradient...

<div style={{fontSize: '0.8em'}}>

```css
.palette.gray .step:nth-child(1) {
  background-color: hsl(0, 0%, 0%);
}
.palette.gray .step:nth-child(2) {
  background-color: hsl(0, 0%, 10%);
}
.palette.gray .step:nth-child(3) {
  background-color: hsl(0, 0%, 20%);
}
.palette.gray .step:nth-child(4) {
  background-color: hsl(0, 0%, 30%);
}
// ...
```

</div>

We can even go a step further and use [for-loops in Sass](https://sass-lang.com/documentation/at-rules/control/for) to make the code less repetitive.

<div style={{fontSize: '0.8em'}}>

```scss
.palette.gray {
  $hue: 0;
  $saturation: 0%;
  @for $i from 0 through 10 {
    .step:nth-child(#{$i + 1}) {
      background-color: hsl($hue, $saturation, $i * 10%);
    }
  }
}
```

</div>

The result looks like this:

<p
  className="codepen"
  data-height="170"
  data-slug-hash="BaRRrRZ"
  data-editable="true"
  data-user="frankno"
  style={{
    height: "170px",
    boxSizing: "border-box",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    border: "2px solid",
    margin: "1em 0",
    padding: "1em",
  }}
>
  <span>
    See the Pen{" "}
    <a href="https://codepen.io/frankno/pen/BaRRrRZ">
      SASS playground
    </a>{" "}
    by francisco (
    <a href="https://codepen.io/frankno">@frankno</a>) on{" "}
    <a href="https://codepen.io">CodePen</a>.
  </span>
</p>
<script
  async
  src="https://cpwebassets.codepen.io/assets/embed/ei.js"
></script>

We can also use JSX to express this color palette, with a component like this:

<div style={{fontSize: '0.8em'}}>

<!-- prettier-ignore -->
```jsx
export const ColorPalette = () => {
  return (
    <div style={{ display: "grid", gridTemplateColumns: "repeat(11, 1fr)" }}>
      {[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100].map((step) => (
        <div
          key={step}
          style={{
            backgroundColor: `hsl(0, 0%, ${step}%)`,
            aspectRatio: "1 / 1",
          }}
        />
      ))}
    </div>
  );
};

```

</div>

<ColorPalette />

So far so good, right? Let's try to apply this to generate palettes in different colors (besides gray)

If we increase the color's **saturation**, (the **s** in **hsl()**) we can see how color starts to appear. In this case, since our hue is 0, we will see the color <strong style={{ color: "red" }}>red</strong>.

Try it yourself: move the saturation slider until you see the box fill up in red.

<SaturationSlider />

We can also increase **hue** (the **h** in **hsl()**), using values from 0 to 360, to get all the color spectrum, from red to green, then from green to blue, and then from blue to red again.

<HueSlider />

Given all we've discovered so far, we could try to create palettes this way. In fact, let's generate a palettes for different hues.

<div style={{ fontSize: "0.8em" }}>

```jsx
<ColorPalette hue={0} />
<ColorPalette hue={60} />
<ColorPalette hue={180} />
<ColorPalette hue={200} />
```

Behind the scenes, I did a small refactor to the ColorSlider component to make it accept hue as a prop. You can see [the component's source code in the github repository for this this website](https://github.com/AeonFr/dev.franciscobrusa.www-next/blob/main/components/blog/generated-color-palettes/ColorPalette.jsx), which is open-source.

</div>

The result we would get surely must be a harmonic color palette, right?

<ColorPalette hue={0} saturation={100} />
<ColorPalette hue={60} saturation={100} />
<ColorPalette hue={180} saturation={100} />
<ColorPalette hue={200} saturation={100} />

Well, as we can see, not so much.

At the 50% luminosity step, for some colors we could easily <span style={{ backgroundColor: 'white', color: 'hsl(0, 100%, 50%)' }}>paint them on a white background</span> and they would still be legible, but for others we have to <span style={{ backgroundColor: 'black', color: 'hsl(180, 100%, 50%)' }}>paint them on a black background</span> to make them legible.

Other colors have steps that are almost impossible to distinguish, so while a purple at 50% luminosity is clearly different than the same purple at 40%, a yellow at 40% luminosity is indistinguishable from a yellow at 40%.

<div
  style={{
    display: "grid",
    gridTemplateColumns: "1fr 1fr",
    gridTemplateRows: "1fr 1fr",
    maxWidth: "20rem",
  }}
>
  {[270, 60].map((hue) => (
    <>
      <div
        style={{
          backgroundColor: `hsl(${hue}, 100%, 50%)`,
          paddingBottom: "100%",
        }}
      />
      <div
        style={{
          backgroundColor: `hsl(${hue}, 100%, 60%)`,
          paddingBottom: "100%",
        }}
      />
    </>
  ))}
</div>

<div style={{ fontSize: '1.2em' }}>

Therefore, **this method to generate palettes is not reliable** to generate button variants or other UI styles. But we've got the math right; **so what is it that went wrong?** **What can we do to get it right?**

</div>

---

## Understanding the color spectrum

Most screens and monitors use the sRGB color spectrum, which basically means they can represent a limited subset of the colors we can see in real life.

<figure style={{  fontSize: "0.8em",  margin: '0 auto', display: 'flex', flexWrap: 'wrap', justifyContent: 'center', gap: '1em' }}>
<img
  src="/blog/generated-color-palettes/CIExy1931_sRGB.svg"
  alt="Visual representation of the sRGB color spectrum inside the 'shoe-shaped' visual spectrum"
  style={{ backgroundColor: 'white', width: '20em' }}
/>

<caption style={{  width: '20em', textAlign: 'left' }}>

**sRGB color spectrum** (black triangle), as compared to the color range visible by the human eye ("shoe shape").

[Via Wikimedia Commons](https://commons.wikimedia.org/wiki/File:CIExy1931_sRGB.svg), [CC BY-SA 3.0](http://creativecommons.org/licenses/by-sa/3.0)

</caption>
</figure>

As a side-note, not all monitors use sRGB, notably, Apple monitors use Apple RGB or Display-P3, color spectrums that allow access to a wider color gamut than sRGB. But the web has not adapted to these technologies yet; right now it's just not possible to represent colors outside of the sRGB spectrum using CSS.
