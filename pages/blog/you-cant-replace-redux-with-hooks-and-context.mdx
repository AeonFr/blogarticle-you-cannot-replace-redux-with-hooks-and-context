export const metadata = {
title: "You can’t replace Redux with Hooks and Context",
date: "2022-12-03",
socialImage: "/blog/you-cant-replace-redux-with-hooks-and-context/social-image.png",
description: "Alternatives to manage state and leave React at what’s good at: rendering the UI.",
thumbnail: "/blog/you-cant-replace-redux-with-hooks-and-context/thumbnail.png",
};

import Image from "next/image"
import Layout from "../../components/Layout";
import {
Layout as ArticleLayout,
TextSlide,
LeadSlide,
TextAndCodeSlide,
CodeStep,
CodeHighlight,
TweetSlide,
} from '../../components/blog/you-cant-replace-redux-with-hooks-and-context'

export default ({children}) => (
<Layout metadata={metadata}>
<ArticleLayout>{children}</ArticleLayout>
</Layout>
);

<LeadSlide>

# You can’t replace Redux with Hooks and Context

React’s Context API is a great tool to share state between components without passing props multiple levels down (something known as prop drilling). Yet, it was never intended to be a state management solution by itself. The problem is that the more state you put in Context, the more times each subscribed component will re‑render. The solution sometimes proposed to bypass this problem is to split context, but this is insufficient for most apps.

Re‑rendering is the biggest performance bottleneck in React, and should be avoided as much as possible. Without the ability to _select_ state, or to subscribe to only certain updates, we can’t really use Context as a _performant_ and _scalable_ solution for state management.

But the same principles that make React re‑render can help us preventing them. In this post, I will explain the different approaches that the most popular state management alternatives use, and **we will even build a basic state-management library from scratch**.

</LeadSlide>

<TextSlide>

---

Unlike frameworks like Vue or Svelte, React does not ship with a Router, a state-management solution, or even a templating engine (JSX can be used, but it’s not mandatory). Even the rendering itself is leveraged to the `react-dom` package. The core React package has a very concrete scope, and it’s not precisely “being a complete state manager solution”.

React’s paradigms and it’s narrow scope allow so much diversity and innovation in the ecosystem, but it is also, contradictorily, what makes it so bad at managing state under any meaningful scale.

One of the paradigms React is buit on is known as “reactive programming” (by the way, it literally inspired its name). Under Reactive Programming, stream are a fundamental concept, and one that will allow us to understand how React reacts (no pun intended) to state changes. This might seem unrelated now, but hang in there, it will be a useful.

</TextSlide>

<TextAndCodeSlide>
<CodeStep>

A stream can represent events, data or other asynchronous sources of information. It can be represented with a line running straight from left to right (representing linear time), that contains a series of dots, representing the events over time.

```

Reactive programming
--------------------

  ┌────────────┐
  │            │
  │   Stream   ├───◉─────◉──────────◉─────────────◉──────
  │            │
  └────────────┘

```

</CodeStep>
<CodeStep>

React state, which includes the result of `useState`, `useReducer`, and a component's props, can be thought of as a stream of data. Each change in that stream, in turn, triggers a _re‑render_. In other words, UI components are subscribed to their state.

```

  ┌────────────┐
  │            │
  │   State    ├───◉─────◉──────────◉─────────────◉──────
  │            │   │     │          │             │
  └────────────┘   │     │          │             │
                   │     │          │             │
  ┌────────────┐   │     │          │             │
  │            │   ▼     ▼          ▼             ▼
  │ Re-renders ├───◉─────◉──────────◉─────────────◉──────
  │            │
  └────────────┘

```

The Context API works just like that. Any change in Context triggers a re‑render on all components using that content. Paradoxically, this same mechanism that's at the core of what React is good at, is also what makes it's state management solution insufficient for some circumstances. Because, sometimes, we don't want to re‑render _every_ component every time the value of context changes. Sometimes we want to _select_ to a part of that state, and only re‑render when that part changes.

</CodeStep>
<CodeStep>

[Redux](https://react-redux.js.org/api/hooks#useselector) solves this with the `useSelector` hook. You can use a single store with a lot of data, but only subscribe your components to a selection of that state. For example, you might only want to track changes in the `name` of a given document.

`useSelector((state) => state.document.name)`

```

  ┌────────────┐
  │            │
  │   Store    ├───◉─────◉──────────◉─────────────◉──────
  │            │   │     │          │             │
  └────────────┘   │     │          │             │
                   │     │          │             │
   <Selector>      │     x          │             x
                   │                │
  ┌────────────┐   │                │
  │            │   ▼                ▼
  │   State    ├───◉────────────────◉────────────────────
  │            │   │                │
  └────────────┘   │                │
                   │                │
  ┌────────────┐   │                │
  │            │   ▼                ▼
  │ Re-renders ├───◉────────────────◉────────────────────
  │            │
  └────────────┘

```

This selector function acts as a filter between the store’s data stream and React’s state stream.
The function is executed any time state changes, but it only “propagates the update” if there is any change in the selected part of the state.

</CodeStep>
</TextAndCodeSlide>
<LeadSlide>

---

The ability to select state is key in making state management scalable and performant.

---

</LeadSlide>
<TextSlide>

Other libraries like [Zustand](https://github.com/pmndrs/zustand) implement this same approach, but without a lot of the “extras” that come with Redux. For example, things like time-travel debugging are not available. Also, Zustand doesn't require you to write your store in a reducer, which also makes the implementation simpler.

I mention this library because its implementation is so small, it even fits in [this tweet](https://twitter.com/dai_shi/status/1583082766081531905) (\*cheating a little).
</TextSlide>

<TweetSlide>

<p lang="en" dir="ltr">Here&#39;s the Zustand code in JS in a tweet.<br/>I think I did this before, but this is slightly a new version.<br/>Not in 140 chars, but in an image. 😅<br/><br/>Source: <a href="https://t.co/SEBiC7bObe">https://unpkg.com/browse/zustand...</a>
</p>
<a href="https://t.co/kLcHnMN5je">
<Image src="https://pbs.twimg.com/media/Ffg5enJUoAAVDjq?format=jpg&name=4096x4096" width={1808} height={2218} alt="tweet's image" />
</a>
&mdash; Daishi Kato (@dai_shi) <a href="https://twitter.com/dai_shi/status/1583082766081531905">October 20, 2022</a>

</TweetSlide>

<TextSlide>

Perhaps you can already understand that implementation, in any case, let me review the basics before digging into libraries like Recoil, that are slightly more complex.

## Building a simple state management library

So far, by convention, I’ve represented **streams** as a series of dots on a line. How can we translate that into code? Turns out it is something you have used already: event listeners. That’s right: to create a stream, you simply need an "object" that dispatches events over time. It's that simple.

Take for example a DOM node that can be clicked: It will dispatch "click" events over time, that any other stream can _subscribe_ to, or _listen_ to. If we checked every button click to update a counter, we could represent that with a graphic like this:

```
  ┌──────────┐
  │  Button  ├───◉────────────────◉──────────────◉─────
  │  clicks  │   │                │              │
  └──────────┘   │                │              │
                 │                │              │
  ┌──────────┐   ▼                ▼              ▼
  │  Update  ├───◉────────────────◉──────────────◉─────
  │  counter │
  └──────────┘
```

We will create a Store that will emit events every time its updated, and allow React to “listen” to those events through a hook, conventionally named `useSelector`.

```
  ┌─────────────────┐
  │  Store’s State  ├───◉─────◉──────────◉─────────◉─────
  └─────────────────┘   │     │          │         │
                        │     │          │         │
      useSelector       │     x          │         x
                        │                │
  ┌─────────────────┐   ▼                ▼
  │  React’s State  ├───◉────────────────◉────────────────
  └─────────────────┘
```

---

### Part 1: Creating the store’s state stream

</TextSlide>
<TextAndCodeSlide>
<CodeStep>

To start implementing this, let’s create a function to instantiate the store, that will define a `state` variable and a set of registered event listeners.

```js
const createStore = (initialState) => {
  let state = initialState;
  const listeners = new Set();

  // ...
};
```

</CodeStep>
<CodeStep>
<CodeHighlight lines={[4,5,6,7,8,9,10]}>

Afterwards, let’s add a `setState` function. It works similarly to React's `useState` hook, allowing us to pass a function to set state based on the previous state, or just a value, to override all state.

</CodeHighlight>

```js
const createStore = (initialState) => {
  let state = initialState;
  const listeners = new Set();

  const setState = (newState) => {
    if (typeof newState === "function") {
      state = newState(state);
    } else {
      state = newState;
    }
  };

  // ...
};
```

<CodeHighlight lines={[6]}>

In other words, we can call the function like this:
`setState(prevState => newState)`

</CodeHighlight>
<CodeHighlight lines={[8]}>

...or like this:
`setState(newState)`

</CodeHighlight>

This store can change its state, but no one can’t subscribe to updates, so it is not a proper stream yet.

</CodeStep>
<CodeStep>
<CodeHighlight lines={[4,5,6,7,8,9]}>

Let’s add an `addListener` function that pushes a new function into our `listeners` set.

</CodeHighlight>
<CodeHighlight lines={[6,7,8]}>

Conveniently, we will return the function to unregister the listener. This means we don't have to define a separate method for this. Also, this will go along nicely with React hooks such as `useEffect` and `useSyncExternalStore` (but more on that later).

</CodeHighlight>
<CodeHighlight lines={[4,5,6,7,8,9]}>

This is kind of API is often refered to as _the subscribe pattern_, or as an _event bus_.

</CodeHighlight>

```js
const createStore = (initialState) => {
  let state = initialState;
  const listeners = new Set();

  const addListener = (listener) => {
    listeners.add(listener);
    return () => {
      listeners.remove(listener);
    };
  };

  const setState = (newState) => {
    // ...
  };

  // ...
};
```

</CodeStep><CodeStep>

<CodeHighlight lines={[7,13]}>

Now we should make the `setState` function call the registered listeners when state is updated. Listeners will be called every time state changes, receiving the new value of state.

</CodeHighlight>

```js
const createStore = (initialState) => {
  let state = initialState;
  const listeners = new Set();
  const addListener = (listener) => {
    // ...
  };

  const setState = (newState) => {
    if (typeof newState === "function") {
      state = newState(state);
    } else {
      state = newState;
    }
    listeners.forEach((listener) => listener(state));
  };

  // ...
};
```

</CodeStep><CodeStep>
<CodeHighlight lines={[10]}>

Finally, we'll just create a function to return the current state. This will be handy later.

</CodeHighlight>

```js
const createStore = (initialState) => {
  let state = initialState;
  const listeners = new Set();
  const addListener = (listener) => {
    // ...
  };
  const setState = (newState) => {
    // ...
  };

  const getState = () => state;

  // ...
};
```

</CodeStep><CodeStep>

Our finished function looks like this:

```js
const createStore = (initialState) => {
  let state = initialState;
  const listeners = new Set();
  const addListener = (listener) => {
    listeners.add(listener);
    return () => {
      listeners.remove(listener);
    };
  };
  const setState = (newState) => {
    if (typeof newState === "function") {
      state = newState(state);
    } else {
      state = newState;
    }
    listeners.forEach((listener) => listener(state));
  };
  const getState = () => state;

  return { addListener, setState, getState };
};
```

</CodeStep>

This is all we need for our stream! ✨ And it fits in ~20 lines of code.
Now we just need a way to "hook it" into the React State stream.

<CodeStep>

### Part 2: The `useSelector` hook

To “hook” our store into React, we will create the `useSelector` function, with a structure like this:

```js
const useSelector = (
  selectorFn = (state) => state,
  isEqualFn = (a, b) => a === b
) => {
  // ...

  return selectorResult;
};
```

</CodeStep>

</TextAndCodeSlide>

<TextSlide>

For the sake of briefness, I’ll keep this code simple, but it wouldn’t be difficult to implement small features like returning also previous state on the `setState` and the `listener` calls. If you need features like middleware support or typescript definitions, you will probably be better using something like Zustand instead. And if you are following the Flux architecture, you will definitely prefer to reach out to Redux.

</TextSlide>
