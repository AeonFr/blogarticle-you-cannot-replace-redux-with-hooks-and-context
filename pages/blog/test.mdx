import BlogCodeWalkthroughLayout from "../../components/BlogCodeWalkthroughLayout";
export default (props) => <BlogCodeWalkthroughLayout {...props} />;

# Composition API

## Reusable **stateful logic** in VueJS

---

## UI as a function of state

One of the core principles of React, Vue and other frameworks or libraries, is that the UI is simply the result of passing **state** through a function.

<small>

(you don't even need a framework to apply this concept)

</small>

```js
UI = fn(state);
```

---

## What is state?

State is data that changes over time.

In other words, a data stream.

---

## What is stateful logic?

Let's see by example. Here we have a vue component.

```html
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
  };
</script>
```

---

Let's focus on the script part only.

<!-- ```diff 7:13 -->
<!-- ``` -->

```html
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
  };
</script>
```

---

We have a state that has the value of the window width. To make this more responsive, we should also add resize eevent handlers to our component.

```html
<template>
  <div>Window width is: {{ windowWidth }}</div>
</template>

<script>
  export default {
    data() {
      return {
        windowWidth: window.innerWidth,
      };
    },
    mounted() {
      window.addEventListener("resize", this.calculateWindowWidth);
    },
    beforeDestroy() {
      window.removeEventListener("resize", this.calculateWindowWidth);
    },
    methods: {
      calculateWindowWidth() {
        this.windowWidth = window.innerWidth;
      },
    },
  };
</script>
```
